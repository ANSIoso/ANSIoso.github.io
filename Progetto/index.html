<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>

	<style>
		body {
			background-color: rgb(54, 53, 53);
		}

		.container {
			position: relative;

			width: 1280px;
			height: 720px;
		}

		.monitor {
			position: absolute;
			left: 0px;
			right: 0px;

			width: 100%;
			height: 100%;
		}

		#uiCanvas {
			z-index: 9;
		}

		#canvas {
			background-color: rgb(51, 50, 50);
		}

		.controls {
			display: none;

			position: absolute;
			z-index: 10;
		}

		.controlsButton {
			min-width: 80px;
			min-height: 80px;
			opacity: 0.2;

			font-size: 30px;
		}

		.controlsButton:active{
			background-color: brown;
		}

		.controlsLine {
			width: 100%;
			text-align: center;
		}

		#leftControls {
			left: 10px;
			bottom: 4px;
		}

		#rightControls {
			right: 10px;
			bottom: 4px;
		}

		@media only screen and (max-width: 1000px) {
			.controls {
				display: inline;
			}

			#container {
				width: 100%;
				height: 50%;
			}
		}
	</style>
</head>

<body>
	<div class="container">
		<canvas id="canvas" class="monitor"></canvas>
		<canvas id="uiCanvas" class="monitor"></canvas>

		<div class="controls" id="leftControls">
			<p class="controlsLine">
				<button id="straight-btn" class="controlsButton"><i class="fa-solid fa-up-long"></i></button>
			</p>
			<p class="controlsLine">
				<button id="left-btn" class="controlsButton"><i class="fa-solid fa-left-long"></i></button>
				<button id="back-btn" class="controlsButton"><i class="fa-solid fa-down-long"></i></button>
				<button id="right-btn" class="controlsButton"><i class="fa-solid fa-right-long"></i></button>
			</p>
		</div>

		<div class="controls" id="rightControls">
			<p>
				<button id="run-btn" class="controlsButton"><i class="fa-solid fa-person-running"></i></button>
			</p>
			<p>
				<button id="light-btn" class="controlsButton"><i class="fa-solid fa-lightbulb"></i></button>
			</p>
		</div>
	</div>

	<script src="https://kit.fontawesome.com/06d84ce8cf.js" crossorigin="anonymous"></script>

	<script id="3d-vertex-shader" type="x-shader/x-vertex">
        attribute vec4 a_position;
		attribute vec2 a_texcoord;
		attribute vec3 a_normal;

		uniform vec3 u_lightWorldPosition;
		uniform vec3 u_viewWorldPosition;

		uniform mat4 u_projection;
		uniform mat4 u_view;
		uniform mat4 u_world;
		uniform mat4 u_textureMatrix;
		
		
		varying vec2 v_texcoord;
		varying vec4 v_projectedTexcoord;
		varying vec3 v_normal;
		
		varying vec3 v_surfaceToLight;
		varying vec3 v_surfaceToView;
		
		// normale
		attribute vec3 a_tangent;
		attribute vec4 a_color;

		varying vec3 v_tangent;
		varying vec4 v_color;


		void main() {
			vec4 worldPosition = u_world * a_position;

			gl_Position = u_projection * u_view * worldPosition;

			v_texcoord = a_texcoord;
			
			v_projectedTexcoord = u_textureMatrix * worldPosition;
			
			mat3 normalMat = mat3(u_world);
			v_normal = normalize(normalMat * a_normal);
			
			v_surfaceToLight = u_lightWorldPosition - worldPosition.xyz;
			v_surfaceToView = u_viewWorldPosition - worldPosition.xyz;
			
			// codice normale
			v_tangent = normalize(normalMat * a_tangent);

			v_color = a_color;
		}
    </script>

	<script id="3d-fragment-shader" type="x-shader/x-fragment">
		precision highp float;

		varying vec2 v_texcoord;
		varying vec4 v_projectedTexcoord;
		varying vec3 v_normal;
		varying vec3 v_surfaceToLight;
		varying vec3 v_surfaceToView;

		varying vec3 v_tangent;
		
		
		varying vec4 v_color; //u_colorMult
		uniform sampler2D diffuseMap; //u_texture
		uniform sampler2D u_projectedTexture;
		uniform float u_bias;
		uniform float shininess;
		uniform vec3 u_lightDirection;
		uniform float u_innerLimit;          // in dot space
		uniform float u_outerLimit;          // in dot space

		uniform vec3 diffuse;
		uniform vec3 ambient;
		uniform vec3 emissive;
		uniform vec3 specular;
		uniform sampler2D specularMap;
		uniform sampler2D normalMap;
		uniform float opacity;

		void main () {
			vec3 normal = normalize(v_normal) * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
			vec3 tangent = normalize(v_tangent) * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
			vec3 bitangent = normalize(cross(normal, tangent));

			mat3 tbn = mat3(tangent, bitangent, normal);
			normal = texture2D(normalMap, v_texcoord).rgb * 2. - 1.;
			normal = normalize(tbn * normal);

			vec3 surfaceToViewDirection = normalize(v_surfaceToView);
			vec3 surfaceToLightDirection = normalize(v_surfaceToLight);


			vec3 halfVector = normalize(surfaceToLightDirection + surfaceToViewDirection);

			float fakeLight = dot(u_lightDirection, normal) * .5 + .5;
			float specularLight = clamp(dot(normal, halfVector), 0.0, 1.0);
			vec4 specularMapColor = texture2D(specularMap, v_texcoord);
			vec3 effectiveSpecular = specular * specularMapColor.rgb;

			vec4 diffuseMapColor = texture2D(diffuseMap, v_texcoord);
			vec3 effectiveDiffuse = diffuse * diffuseMapColor.rgb * v_color.rgb;
			float effectiveOpacity = opacity * diffuseMapColor.a * v_color.a;


			float dotFromDirection = dot(surfaceToLightDirection,
                               -u_lightDirection);
			float limitRange = u_innerLimit - u_outerLimit;
			float inLight = clamp((dotFromDirection - u_outerLimit) / limitRange, 0.1, 1.0); // |modificare qui per indicare
			float light = inLight * dot(normal, surfaceToLightDirection);                    // |oscurità fuori dal cono di luce

			// codice proiezione
			// divide by w to get the correct value. See article on perspective
			vec3 projectedTexcoord = v_projectedTexcoord.xyz / v_projectedTexcoord.w;
			float currentDepth = projectedTexcoord.z + u_bias;
			
			bool inRange = 
				projectedTexcoord.x >= 0.0 &&
				projectedTexcoord.x <= 1.0 &&
				projectedTexcoord.y >= 0.0 &&
				projectedTexcoord.y <= 1.0;

			float projectedDepth = texture2D(u_projectedTexture, projectedTexcoord.xy).r;
			float shadowLight = (inRange && projectedDepth <= currentDepth) ? 0.1 : 1.0;  // modificare qui per indicare
																						  // oscurità ombra oggerri
			
			gl_FragColor = vec4(
				emissive +
				effectiveDiffuse * light * shadowLight +
				effectiveSpecular * inLight * pow(specularLight, shininess) * shadowLight,
				effectiveOpacity);
		}
	</script>

	<!-- v_ shadow map shader _v -->

	<script id="color-vertex-shader" type="x-shader/x-vertex">
		attribute vec4 a_position;
		
		uniform mat4 u_projection;
		uniform mat4 u_view;
		uniform mat4 u_world;
		
		void main() {
		  // Multiply the position by the matrices.
		  gl_Position = u_projection * u_view * u_world * a_position;
		}
	</script>

	<script id="color-fragment-shader" type="x-shader/x-fragment">
		precision mediump float;
		
		uniform vec4 u_color;
		void main() {
		  gl_FragColor = u_color;
		}
	</script>

	<!-- v_ skybox shader _v -->

	<script id="skybox-vertex-shader" type="x-shader/x-vertex">
		attribute vec4 a_position;
		varying vec4 v_position;
		
		void main() {
		  v_position = a_position;
		  gl_Position = a_position;
		  gl_Position.z = 1.0;
		}
	</script>

	<script id="skybox-fragment-shader" type="x-shader/x-fragment">
		precision mediump float;
		
		uniform samplerCube u_skybox;
		uniform mat4 u_viewDirectionProjectionInverse;
		
		varying vec4 v_position;
		void main() {
		  vec4 t = u_viewDirectionProjectionInverse * v_position;
		  gl_FragColor = textureCube(u_skybox, normalize(t.xyz / t.w));
		}
	</script>

	<script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
	<script src="https://webglfundamentals.org/webgl/resources/m4.js"></script>

	<!-- model -->
	<script src="Model/game.js"></script>

	<!-- engine -->
	<script src="Engine/textureHelpers.js"></script>
	<script src="Engine/objParsers.js"></script>
	<script src="Engine/engine.js"></script>

	<!-- controller -->
	<script src="Controller/playerController.js"></script>

</body>

</html>